<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>CDP Portfolio Optimisation</title>
<!-- 2018-08-28 Tue 22:44 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Lev Livnev" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">CDP Portfolio Optimisation</h1>
<p>
We can approximate the liquidation probability of a single CDP as a function of its collateralisation, using a normal approximation for returns:
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">import</span> scipy.special

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">cumulative_normal</span>(x, mu=0, sigma=1.0):
    <span style="color: #859900; font-weight: bold;">return</span> 0.5 * (1 + scipy.special.erf((x - mu)/(np.sqrt(2) * sigma)))

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">liquidation_probability</span>(ink, tab, tag, mat, sigma):
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">assumes normal distribution of returns over period</span>
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">return to liquidation:</span>
    <span style="color: #268bd2;">hit</span> = mat / (ink * tag / tab) - 1
    <span style="color: #859900; font-weight: bold;">return</span> cumulative_normal(hit, sigma=sigma)
</pre>
</div>

<p>
Now we construct the optimisation objective for our problem. We want to distribute the desired debt \( D \) between \( N \) CDPs so as to minimise the probability that any CDP will be liquidated. To simplify this calculation, we make it a calculation of relative, rather than absolute risk, so we decide to go for the objective of having each CDP equally likely to be liquidated. Let \( p_i \) be the liquidation probability of CDP \( i \), which is a function of \( {\tt tab}_i \). Let \( R_i \) be the random variable representing the asset's return over some period, then we have:
</p>

<p>
\[
p_i = \mathbb{P}(R_i < \frac{{\tt mat}_i\cdot {\tt tag}_i}{{\tt ink}_i \cdot {\tt tag}_i} - 1)
\]
</p>

<p>
The loss we will want to minimise is the sum of the magnitudes of the pairwise differences of the liquidation probabilities. The idea is that the optimum is achieved when all CDPs have the same probability of getting liquidated:
</p>


<p>
\[
f({\tt tabs}) = \Sigma_{i=0}^N \Sigma_{j=0}^i \| p_i - p_j \|
\]
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">make_risk_parity_objective</span>(inks, tags, mats, sigmas):
    <span style="color: #268bd2;">N</span> = <span style="color: #657b83; font-weight: bold;">len</span>(inks)
    <span style="color: #268bd2;">lp</span> = <span style="color: #859900; font-weight: bold;">lambda</span> tab, i: liquidation_probability(inks[i], tab, tags[i], mats[i], sigmas[i])
    <span style="color: #268bd2;">f</span> = <span style="color: #859900; font-weight: bold;">lambda</span> tabs: <span style="color: #657b83; font-weight: bold;">sum</span>([<span style="color: #657b83; font-weight: bold;">sum</span>([<span style="color: #657b83; font-weight: bold;">abs</span>(lp(tabs[i], i) - lp(tabs[j], j)) <span style="color: #859900; font-weight: bold;">for</span> j <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #657b83; font-weight: bold;">range</span>(0, i)]) <span style="color: #859900; font-weight: bold;">for</span> i <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #657b83; font-weight: bold;">range</span>(0, N)])
    <span style="color: #859900; font-weight: bold;">return</span> f
</pre>
</div>

<p>
We will need to use some optimisation algorithm to find the minimum of this loss function, since no closed-form solution exists. Many options are probably suitable, e.g. hill-climbing, gradient descent, etc., we choose simulated annealing for simplicity. Here's a simple implementation of simulated annealing:
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">import</span> numpy <span style="color: #859900; font-weight: bold;">as</span> np

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">neighbour</span>(xs, sigma=0.1):
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">geometric brownian step</span>
    <span style="color: #268bd2;">new_xs</span> = xs * (1 + np.random.normal(0, sigma, size=<span style="color: #657b83; font-weight: bold;">len</span>(xs)))
    <span style="color: #859900; font-weight: bold;">return</span> new_xs

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">optimise_by_annealing</span>(f, n,
                          init=<span style="color: #268bd2; font-weight: bold;">None</span>,
                          scale=<span style="color: #859900; font-weight: bold;">lambda</span> x: x,
                          tol=1,
                          max_iter=1000,
                          init_temperature=100.0,
                          cool=0.999):
    <span style="color: #859900; font-weight: bold;">if</span> init == <span style="color: #268bd2; font-weight: bold;">None</span>:
        <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">make some initial starting values:</span>
        <span style="color: #268bd2;">xs</span> = scale(np.ones(n))
    <span style="color: #859900; font-weight: bold;">else</span>:
        <span style="color: #268bd2;">xs</span> = scale(init)
    <span style="color: #268bd2;">temperature</span> = init_temperature
    <span style="color: #859900; font-weight: bold;">for</span> i <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #657b83; font-weight: bold;">range</span>(max_iter):
        <span style="color: #268bd2;">loss</span> = f(xs)
        <span style="color: #859900; font-weight: bold;">if</span> loss &lt; tol:
            <span style="color: #859900; font-weight: bold;">break</span>
        <span style="color: #268bd2;">candidate</span> = scale(neighbour(xs))
        <span style="color: #268bd2;">candidate_loss</span> = f(candidate)
        <span style="color: #859900; font-weight: bold;">if</span> candidate_loss &lt; loss:
            <span style="color: #268bd2;">xs</span> = candidate
        <span style="color: #859900; font-weight: bold;">else</span>:
            <span style="color: #859900; font-weight: bold;">if</span> np.random.uniform() &lt; np.exp(-(candidate_loss - loss) / temperature):
                <span style="color: #268bd2;">xs</span> = candidate
        <span style="color: #268bd2;">temperature</span> *= cool
    <span style="color: #859900; font-weight: bold;">print</span>(<span style="color: #2aa198;">"Ran annealing for {} iterations."</span>.<span style="color: #657b83; font-weight: bold;">format</span>(i+1))
    <span style="color: #859900; font-weight: bold;">return</span> xs, loss
</pre>
</div>

<p>
Applying this algorithm to the loss defined above, we can work through a simple example of two assets, `ETH` and `DGX`:
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">do_example_with_2</span>():
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">ETH and DGX</span>
    <span style="color: #268bd2;">gems</span> = [<span style="color: #2aa198;">"ETH"</span>, <span style="color: #2aa198;">"DGX"</span>]
    <span style="color: #268bd2;">tags</span> = [420., 38.]
    <span style="color: #268bd2;">inks</span> = [10., 100.]
    <span style="color: #268bd2;">mats</span> = [1.5, 1.1]
    <span style="color: #268bd2;">sigmas</span> = [0.2, 0.1]
    <span style="color: #268bd2;">f</span> = make_risk_parity_objective(inks, tags, mats, sigmas)
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">target debt: 3000 dai</span>
    <span style="color: #268bd2;">D</span> = 3000
    <span style="color: #268bd2;">tabs</span>, <span style="color: #268bd2;">loss</span> = optimise_by_annealing(f, 2, scale=(<span style="color: #859900; font-weight: bold;">lambda</span> tabs: D * tabs / <span style="color: #657b83; font-weight: bold;">sum</span>(tabs)), tol=.0000001, max_iter=100000)
    <span style="color: #859900; font-weight: bold;">print</span>(<span style="color: #2aa198;">"Results:"</span>)
    <span style="color: #859900; font-weight: bold;">for</span> i, gem <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #657b83; font-weight: bold;">enumerate</span>(gems):
      <span style="color: #859900; font-weight: bold;">print</span>(<span style="color: #2aa198;">"{} CDP: tab={}"</span>.<span style="color: #657b83; font-weight: bold;">format</span>(gem, tabs[i]))
      <span style="color: #859900; font-weight: bold;">print</span>(<span style="color: #2aa198;">"(collateral ratio={}, liquidation probability={})"</span>.<span style="color: #657b83; font-weight: bold;">format</span>(inks[i]*tags[i]/tabs[i], liquidation_probability(inks[i], tabs[i], tags[i], mats[i], sigmas[i])))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-python">do_example_with_2()
</pre>
</div>

<pre class="example">
Ran annealing for 12113 iterations.
Results:
ETH CDP: tab=787.1685180183765
(collateral ratio=5.3355792360358985, liquidation probability=0.00016260625537189988)
DGX CDP: tab=2212.8314819816237
(collateral ratio=1.7172568408133109, liquidation probability=0.0001625480310186722)
</pre>
</div>
<div id="postamble" class="status">
<p class="date">Date: <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-08-28 Tue&gt;</span></span></p>
<p class="author">Author: Lev Livnev</p>
<p class="date">Created: 2018-08-28 Tue 22:44</p>
<p class="creator">Emacs 25.2.2 (Org mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
